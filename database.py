import aiosqlite
import logging
import os
from datetime import datetime
from typing import Optional
from pathlib import Path

logger = logging.getLogger(__name__)

class Database:
    def __init__(self, db_path='places.db'):
        # –ï—Å–ª–∏ –µ—Å—Ç—å Volume –≤ Railway, –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ
        volume_path = Path('/app/data')
        if volume_path.exists() and volume_path.is_dir():
            self.db_path = str(volume_path / 'places.db')
            logger.info(f"üì¶ –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ: {self.db_path}")
        else:
            self.db_path = db_path
            logger.info(f"üíæ –ò—Å–ø–æ–ª—å–∑—É–µ–º –ª–æ–∫–∞–ª—å–Ω—É—é –±–∞–∑—É: {self.db_path}")
        self._connection: Optional[aiosqlite.Connection] = None
    
    async def connect(self):
        """–û—Ç–∫—Ä—ã—Ç—å –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –ë–î"""
        if self._connection is None:
            self._connection = await aiosqlite.connect(self.db_path)
            self._connection.row_factory = aiosqlite.Row
        return self._connection
    
    async def close(self):
        """–ó–∞–∫—Ä—ã—Ç—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –ë–î"""
        if self._connection:
            await self._connection.close()
            self._connection = None
    
    async def init_db(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
        db = await self.connect()
        try:
            await db.execute('''
                CREATE TABLE IF NOT EXISTS places (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    name TEXT NOT NULL,
                    place_type TEXT,
                    price_category TEXT,
                    status TEXT DEFAULT 'visited',
                    review TEXT,
                    address TEXT,
                    description TEXT,
                    latitude REAL,
                    longitude REAL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            # –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ –∫–æ–ª–æ–Ω–∫–∏ –µ—Å–ª–∏ —Ç–∞–±–ª–∏—Ü–∞ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç (–º–∏–≥—Ä–∞—Ü–∏—è)
            try:
                await db.execute('ALTER TABLE places ADD COLUMN status TEXT DEFAULT "visited"')
            except:
                pass  # –ö–æ–ª–æ–Ω–∫–∞ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            
            try:
                await db.execute('ALTER TABLE places ADD COLUMN review TEXT')
            except:
                pass  # –ö–æ–ª–æ–Ω–∫–∞ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            
            try:
                await db.execute('ALTER TABLE places ADD COLUMN social_link TEXT')
            except:
                pass  # –ö–æ–ª–æ–Ω–∫–∞ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            
            try:
                await db.execute('ALTER TABLE places ADD COLUMN cuisine TEXT')
            except:
                pass  # –ö–æ–ª–æ–Ω–∫–∞ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            
            try:
                await db.execute('ALTER TABLE places ADD COLUMN working_hours TEXT')
            except:
                pass  # –ö–æ–ª–æ–Ω–∫–∞ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            
            # –°–æ–∑–¥–∞–µ–º –∏–Ω–¥–µ–∫—Å—ã –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤
            await db.execute('''
                CREATE INDEX IF NOT EXISTS idx_user_id ON places(user_id)
            ''')
            await db.execute('''
                CREATE INDEX IF NOT EXISTS idx_place_type ON places(place_type)
            ''')
            await db.execute('''
                CREATE INDEX IF NOT EXISTS idx_created_at ON places(created_at DESC)
            ''')
            await db.execute('''
                CREATE INDEX IF NOT EXISTS idx_status ON places(status)
            ''')
            
            # –¢–∞–±–ª–∏—Ü–∞ –¥–ª—è —á–∞–µ–≤—ã—Ö (—Å–º–µ–Ω)
            await db.execute('''
                CREATE TABLE IF NOT EXISTS tips (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    tips_date TEXT NOT NULL,
                    card_amount REAL DEFAULT 0,
                    netmonet_amount REAL DEFAULT 0,
                    cash_amount REAL DEFAULT 0,
                    total_amount REAL NOT NULL,
                    hours_worked REAL DEFAULT 0,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—É—é –∫–æ–ª–æ–Ω–∫—É –µ—Å–ª–∏ —Ç–∞–±–ª–∏—Ü–∞ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç (–º–∏–≥—Ä–∞—Ü–∏—è)
            try:
                await db.execute('ALTER TABLE tips ADD COLUMN hours_worked REAL DEFAULT 0')
            except:
                pass  # –ö–æ–ª–æ–Ω–∫–∞ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            
            # –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è —Ç–∞–±–ª–∏—Ü—ã —á–∞–µ–≤—ã—Ö
            await db.execute('''
                CREATE INDEX IF NOT EXISTS idx_tips_user_id ON tips(user_id)
            ''')
            await db.execute('''
                CREATE INDEX IF NOT EXISTS idx_tips_date ON tips(tips_date DESC)
            ''')
            
            # –¢–∞–±–ª–∏—Ü–∞ –¥–ª—è –ø—Ä–æ–¥–∞–∂ –ê–≤–∏—Ç–æ
            await db.execute('''
                CREATE TABLE IF NOT EXISTS avito_sales (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    item_name TEXT NOT NULL,
                    amount REAL NOT NULL,
                    sale_date TEXT NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è —Ç–∞–±–ª–∏—Ü—ã –ê–≤–∏—Ç–æ
            await db.execute('''
                CREATE INDEX IF NOT EXISTS idx_avito_user_id ON avito_sales(user_id)
            ''')
            await db.execute('''
                CREATE INDEX IF NOT EXISTS idx_avito_date ON avito_sales(sale_date DESC)
            ''')
            
            # –¢–∞–±–ª–∏—Ü–∞ –¥–ª—è —Ç—Ä–∞—Ç
            await db.execute('''
                CREATE TABLE IF NOT EXISTS expenses (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    category TEXT NOT NULL,
                    name TEXT NOT NULL,
                    amount REAL NOT NULL,
                    expense_date TEXT NOT NULL,
                    note TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è —Ç–∞–±–ª–∏—Ü—ã —Ç—Ä–∞—Ç
            await db.execute('''
                CREATE INDEX IF NOT EXISTS idx_expenses_user_id ON expenses(user_id)
            ''')
            await db.execute('''
                CREATE INDEX IF NOT EXISTS idx_expenses_date ON expenses(expense_date DESC)
            ''')
            await db.execute('''
                CREATE INDEX IF NOT EXISTS idx_expenses_category ON expenses(category)
            ''')
            
            # –¢–∞–±–ª–∏—Ü–∞ –¥–ª—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö —Ä–∞—Å—Ö–æ–¥–æ–≤
            await db.execute('''
                CREATE TABLE IF NOT EXISTS recurring_expenses (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    name TEXT NOT NULL,
                    amount REAL NOT NULL,
                    payment_date TEXT NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è —Ç–∞–±–ª–∏—Ü—ã –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö —Ä–∞—Å—Ö–æ–¥–æ–≤
            await db.execute('''
                CREATE INDEX IF NOT EXISTS idx_recurring_expenses_user_id ON recurring_expenses(user_id)
            ''')
            await db.execute('''
                CREATE INDEX IF NOT EXISTS idx_recurring_expenses_date ON recurring_expenses(payment_date)
            ''')
            
            # –¢–∞–±–ª–∏—Ü–∞ –¥–ª—è —Ñ–∏–ª—å–º–æ–≤
            await db.execute('''
                CREATE TABLE IF NOT EXISTS movies (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    title TEXT NOT NULL,
                    genre TEXT,
                    year INTEGER,
                    overview TEXT,
                    status TEXT NOT NULL,
                    rating INTEGER,
                    notes TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # –ú–∏–≥—Ä–∞—Ü–∏—è: –¥–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª–µ overview –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç
            try:
                await db.execute('ALTER TABLE movies ADD COLUMN overview TEXT')
            except:
                pass  # –ü–æ–ª–µ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            
            await db.execute('''
                CREATE INDEX IF NOT EXISTS idx_movies_user_id ON movies(user_id)
            ''')
            
            # –¢–∞–±–ª–∏—Ü–∞ –¥–ª—è —Å–µ—Ä–∏–∞–ª–æ–≤
            await db.execute('''
                CREATE TABLE IF NOT EXISTS series (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    title TEXT NOT NULL,
                    genre TEXT,
                    year INTEGER,
                    overview TEXT,
                    seasons INTEGER,
                    episodes INTEGER,
                    status TEXT NOT NULL,
                    rating INTEGER,
                    notes TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # –ú–∏–≥—Ä–∞—Ü–∏—è: –¥–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ –ø–æ–ª—è –¥–ª—è series –µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç
            try:
                await db.execute('ALTER TABLE series ADD COLUMN overview TEXT')
            except:
                pass  # –ü–æ–ª–µ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            try:
                await db.execute('ALTER TABLE series ADD COLUMN seasons INTEGER')
            except:
                pass  # –ü–æ–ª–µ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            try:
                await db.execute('ALTER TABLE series ADD COLUMN episodes INTEGER')
            except:
                pass  # –ü–æ–ª–µ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            
            await db.execute('''
                CREATE INDEX IF NOT EXISTS idx_series_user_id ON series(user_id)
            ''')
            
            # –¢–∞–±–ª–∏—Ü–∞ –¥–ª—è –ø–æ–¥–∫–∞—Å—Ç–æ–≤
            await db.execute('''
                CREATE TABLE IF NOT EXISTS podcasts (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    title TEXT NOT NULL,
                    author TEXT,
                    status TEXT NOT NULL,
                    rating INTEGER,
                    notes TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            await db.execute('''
                CREATE INDEX IF NOT EXISTS idx_podcasts_user_id ON podcasts(user_id)
            ''')
            
            # –¢–∞–±–ª–∏—Ü–∞ –∑–∞–º–µ—Ç–æ–∫
            await db.execute('''
                CREATE TABLE IF NOT EXISTS notes (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    category TEXT NOT NULL,
                    text TEXT NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            await db.execute('''
                CREATE INDEX IF NOT EXISTS idx_notes_user_id ON notes(user_id)
            ''')
            
            await db.execute('''
                CREATE INDEX IF NOT EXISTS idx_notes_category ON notes(category)
            ''')
            
            # –¢–∞–±–ª–∏—Ü–∞ –≤–∏—à–ª–∏—Å—Ç–∞
            await db.execute('''
                CREATE TABLE IF NOT EXISTS wishlist (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    name TEXT NOT NULL,
                    size_category TEXT NOT NULL,
                    type_category TEXT NOT NULL,
                    price REAL,
                    priority TEXT,
                    photo_url TEXT,
                    link TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            await db.execute('''
                CREATE INDEX IF NOT EXISTS idx_wishlist_user_id ON wishlist(user_id)
            ''')
            
            await db.execute('''
                CREATE INDEX IF NOT EXISTS idx_wishlist_priority ON wishlist(priority)
            ''')
            
            # –¢–∞–±–ª–∏—Ü–∞ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π
            await db.execute('''
                CREATE TABLE IF NOT EXISTS reminders (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    priority INTEGER NOT NULL,
                    reminder_datetime TEXT NOT NULL,
                    note TEXT NOT NULL,
                    sent INTEGER DEFAULT 0,
                    repeat_type TEXT DEFAULT 'none',
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            await db.execute('''
                CREATE INDEX IF NOT EXISTS idx_reminders_user_id ON reminders(user_id)
            ''')
            
            # –ú–∏–≥—Ä–∞—Ü–∏—è: –¥–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª–µ repeat_type –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç
            try:
                await db.execute('ALTER TABLE reminders ADD COLUMN repeat_type TEXT DEFAULT "none"')
            except:
                pass  # –ü–æ–ª–µ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            
            await db.execute('''
                CREATE INDEX IF NOT EXISTS idx_reminders_datetime ON reminders(reminder_datetime)
            ''')
            
            # –¢–∞–±–ª–∏—Ü–∞ –∫–∞–¥—Ä–æ–≤ –¥–ª—è –≤–∏–¥–µ–æ–≥—Ä–∞—Ñ–∏–∏
            await db.execute('''
                CREATE TABLE IF NOT EXISTS video_frames (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    title TEXT NOT NULL,
                    description TEXT NOT NULL,
                    instructions TEXT,
                    duration INTEGER,
                    order_index INTEGER DEFAULT 0,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            await db.execute('''
                CREATE INDEX IF NOT EXISTS idx_video_frames_user_id ON video_frames(user_id)
            ''')
            
            await db.execute('''
                CREATE INDEX IF NOT EXISTS idx_video_frames_order ON video_frames(user_id, order_index)
            ''')
            
            # –¢–∞–±–ª–∏—Ü–∞ –∏–¥–µ–π
            await db.execute('''
                CREATE TABLE IF NOT EXISTS ideas (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    category TEXT NOT NULL,
                    idea_text TEXT NOT NULL,
                    songs TEXT,
                    priority INTEGER DEFAULT 3,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            await db.execute('''
                CREATE INDEX IF NOT EXISTS idx_ideas_user_id ON ideas(user_id)
            ''')
            
            await db.execute('''
                CREATE INDEX IF NOT EXISTS idx_ideas_priority ON ideas(user_id, priority)
            ''')
            
            await db.execute('''
                CREATE INDEX IF NOT EXISTS idx_reminders_sent ON reminders(sent)
            ''')
            
            await db.commit()
            logger.info("–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ë–î: {e}")
            raise
    
    async def add_place(self, user_id: int, name: str, place_type: str = None,
                       price_category: str = None, status: str = 'visited', 
                       review: str = None, address: str = None, 
                       description: str = None, latitude: float = None, 
                       longitude: float = None, social_link: str = None, cuisine: str = None,
                       working_hours: str = None):
        """–î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤–æ–µ –º–µ—Å—Ç–æ"""
        try:
            db = await self.connect()
            cursor = await db.execute('''
                INSERT INTO places (user_id, name, place_type, price_category, status, review, address, description, latitude, longitude, social_link, cuisine, working_hours)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (user_id, name, place_type, price_category, status, review, address, description, latitude, longitude, social_link, cuisine, working_hours))
            await db.commit()
            return cursor.lastrowid
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –º–µ—Å—Ç–∞: {e}")
            return None
    
    async def get_user_places(self, user_id: int, place_type: str = None, status: str = None, limit: int = None, offset: int = 0):
        """–ü–æ–ª—É—á–∏—Ç—å –º–µ—Å—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π"""
        try:
            db = await self.connect()
            # –°—Ç—Ä–æ–∏–º –∑–∞–ø—Ä–æ—Å —Å —É—á–µ—Ç–æ–º —Ñ–∏–ª—å—Ç—Ä–æ–≤
            conditions = ["user_id = ?"]
            params = [user_id]
            
            if place_type:
                conditions.append("place_type = ?")
                params.append(place_type)
            
            if status:
                conditions.append("status = ?")
                params.append(status)
            
            query = f"SELECT * FROM places WHERE {' AND '.join(conditions)} ORDER BY created_at DESC"
            
            if limit:
                query += ' LIMIT ? OFFSET ?'
                params = params + [limit, offset]
            
            async with db.execute(query, tuple(params)) as cursor:
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –º–µ—Å—Ç: {e}")
            return []
    
    async def get_place(self, place_id: int, user_id: int):
        """–ü–æ–ª—É—á–∏—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–µ –º–µ—Å—Ç–æ"""
        try:
            db = await self.connect()
            async with db.execute(
                'SELECT * FROM places WHERE id = ? AND user_id = ?',
                (place_id, user_id)
            ) as cursor:
                row = await cursor.fetchone()
                return dict(row) if row else None
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –º–µ—Å—Ç–∞: {e}")
            return None
    
    async def update_place(self, place_id: int, user_id: int, **kwargs):
        """–û–±–Ω–æ–≤–∏—Ç—å –º–µ—Å—Ç–æ"""
        try:
            db = await self.connect()
            # –§–æ—Ä–º–∏—Ä—É–µ–º SET —á–∞—Å—Ç—å –∑–∞–ø—Ä–æ—Å–∞ —Ç–æ–ª—å–∫–æ –¥–ª—è –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã—Ö –ø–æ–ª–µ–π
            set_parts = []
            values = []
            for key, value in kwargs.items():
                if value is not None:
                    set_parts.append(f"{key} = ?")
                    values.append(value)
            
            if not set_parts:
                return False
            
            values.extend([place_id, user_id])
            query = f"UPDATE places SET {', '.join(set_parts)} WHERE id = ? AND user_id = ?"
            await db.execute(query, values)
            await db.commit()
            return True
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –º–µ—Å—Ç–∞: {e}")
            return False
    
    async def delete_place(self, place_id: int, user_id: int):
        """–£–¥–∞–ª–∏—Ç—å –º–µ—Å—Ç–æ"""
        try:
            db = await self.connect()
            await db.execute(
                'DELETE FROM places WHERE id = ? AND user_id = ?',
                (place_id, user_id)
            )
            await db.commit()
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –º–µ—Å—Ç–∞: {e}")
    
    async def search_places(self, user_id: int, query: str):
        """–ü–æ–∏—Å–∫ –º–µ—Å—Ç –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é, –∞–¥—Ä–µ—Å—É, –æ–ø–∏—Å–∞–Ω–∏—é –∏–ª–∏ —Ç–∏–ø—É"""
        try:
            db = await self.connect()
            async with db.execute('''
                SELECT * FROM places 
                WHERE user_id = ? AND (name LIKE ? OR address LIKE ? OR description LIKE ? OR place_type LIKE ?)
                ORDER BY created_at DESC
            ''', (user_id, f'%{query}%', f'%{query}%', f'%{query}%', f'%{query}%')) as cursor:
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ –º–µ—Å—Ç: {e}")
            return []
    
    async def count_user_places(self, user_id: int, place_type: str = None, status: str = None):
        """–ü–æ–¥—Å—á–∏—Ç–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–µ—Å—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            db = await self.connect()
            # –°—Ç—Ä–æ–∏–º –∑–∞–ø—Ä–æ—Å —Å —É—á–µ—Ç–æ–º —Ñ–∏–ª—å—Ç—Ä–æ–≤
            conditions = ["user_id = ?"]
            params = [user_id]
            
            if place_type:
                conditions.append("place_type = ?")
                params.append(place_type)
            
            if status:
                conditions.append("status = ?")
                params.append(status)
            
            query = f"SELECT COUNT(*) as count FROM places WHERE {' AND '.join(conditions)}"
            
            async with db.execute(query, tuple(params)) as cursor:
                row = await cursor.fetchone()
                return row['count'] if row else 0
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥—Å—á–µ—Ç–µ –º–µ—Å—Ç: {e}")
            return 0
    
    # ===== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ß–ê–ï–í–´–• =====
    
    async def add_tips(self, user_id: int, tips_date: str, card_amount: float = 0,
                      netmonet_amount: float = 0, cash_amount: float = 0, total_amount: float = 0,
                      hours_worked: float = 0):
        """–î–æ–±–∞–≤–∏—Ç—å –∑–∞–ø–∏—Å—å –æ —á–∞–µ–≤—ã—Ö (—Å–º–µ–Ω–µ)"""
        try:
            db = await self.connect()
            cursor = await db.execute('''
                INSERT INTO tips (user_id, tips_date, card_amount, netmonet_amount, cash_amount, total_amount, hours_worked)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            ''', (user_id, tips_date, card_amount, netmonet_amount, cash_amount, total_amount, hours_worked))
            await db.commit()
            return cursor.lastrowid
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —á–∞–µ–≤—ã—Ö: {e}")
            return None
    
    async def get_user_tips(self, user_id: int, limit: int = None, offset: int = 0):
        """–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ —á–∞–µ–≤—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            db = await self.connect()
            query = 'SELECT * FROM tips WHERE user_id = ? ORDER BY tips_date DESC, created_at DESC'
            if limit:
                query += f' LIMIT {limit} OFFSET {offset}'
            
            async with db.execute(query, (user_id,)) as cursor:
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —á–∞–µ–≤—ã—Ö: {e}")
            return []
    
    async def count_user_tips(self, user_id: int):
        """–ü–æ–¥—Å—á–∏—Ç–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–ø–∏—Å–µ–π –æ —á–∞–µ–≤—ã—Ö"""
        try:
            db = await self.connect()
            async with db.execute('SELECT COUNT(*) as count FROM tips WHERE user_id = ?', (user_id,)) as cursor:
                row = await cursor.fetchone()
                return row['count'] if row else 0
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥—Å—á–µ—Ç–µ —á–∞–µ–≤—ã—Ö: {e}")
            return 0
    
    async def get_tips_stats(self, user_id: int):
        """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ —á–∞–µ–≤—ã–º"""
        try:
            db = await self.connect()
            async with db.execute('''
                SELECT 
                    COUNT(*) as shifts_count,
                    SUM(card_amount) as total_card,
                    SUM(netmonet_amount) as total_netmonet,
                    SUM(cash_amount) as total_cash,
                    SUM(total_amount) as total_tips,
                    AVG(total_amount) as avg_tips
                FROM tips WHERE user_id = ?
            ''', (user_id,)) as cursor:
                row = await cursor.fetchone()
                return dict(row) if row else None
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —á–∞–µ–≤—ã—Ö: {e}")
            return None
    
    async def delete_tips(self, tips_id: int, user_id: int):
        """–£–¥–∞–ª–∏—Ç—å –∑–∞–ø–∏—Å—å –æ —á–∞–µ–≤—ã—Ö"""
        try:
            db = await self.connect()
            await db.execute(
                'DELETE FROM tips WHERE id = ? AND user_id = ?',
                (tips_id, user_id)
            )
            await db.commit()
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —á–∞–µ–≤—ã—Ö: {e}")
    
    async def get_tips_months(self, user_id: int):
        """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –º–µ—Å—è—Ü–µ–≤ —Å —á–∞–µ–≤—ã–º–∏"""
        try:
            db = await self.connect()
            # –ò–∑–≤–ª–µ–∫–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –º–µ—Å—è—Ü—ã –∏–∑ –¥–∞—Ç (—Ñ–æ—Ä–º–∞—Ç DD.MM.YYYY)
            async with db.execute('''
                SELECT DISTINCT substr(tips_date, 4, 7) as month_year
                FROM tips 
                WHERE user_id = ?
                ORDER BY substr(tips_date, 7, 4) DESC, substr(tips_date, 4, 2) DESC
            ''', (user_id,)) as cursor:
                rows = await cursor.fetchall()
                return [row['month_year'] for row in rows]
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –º–µ—Å—è—Ü–µ–≤: {e}")
            return []
    
    async def get_tips_stats_by_month(self, user_id: int, month_year: str):
        """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ —á–∞–µ–≤—ã–º (—Å–º–µ–Ω–∞–º) –∑–∞ –º–µ—Å—è—Ü (—Ñ–æ—Ä–º–∞—Ç MM.YYYY)"""
        try:
            db = await self.connect()
            # –ò—â–µ–º –∑–∞–ø–∏—Å–∏ –≥–¥–µ –¥–∞—Ç–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç –º–µ—Å—è—Ü –∏ –≥–æ–¥
            async with db.execute('''
                SELECT 
                    COUNT(*) as shifts_count,
                    SUM(card_amount) as total_card,
                    SUM(netmonet_amount) as total_netmonet,
                    SUM(cash_amount) as total_cash,
                    SUM(total_amount) as total_tips,
                    SUM(hours_worked) as total_hours,
                    AVG(total_amount) as avg_tips
                FROM tips 
                WHERE user_id = ? AND substr(tips_date, 4, 7) = ?
            ''', (user_id, month_year)) as cursor:
                row = await cursor.fetchone()
                return dict(row) if row else None
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∑–∞ –º–µ—Å—è—Ü: {e}")
            return None
    
    async def get_tips_stats_by_period(self, user_id: int, start_date: str, end_date: str):
        """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ —á–∞–µ–≤—ã–º –∑–∞ –ø–µ—Ä–∏–æ–¥ (—Ñ–æ—Ä–º–∞—Ç DD.MM.YYYY)"""
        try:
            db = await self.connect()
            async with db.execute('''
                SELECT 
                    COUNT(*) as shifts_count,
                    SUM(card_amount) as total_card,
                    SUM(netmonet_amount) as total_netmonet,
                    SUM(cash_amount) as total_cash,
                    SUM(total_amount) as total_tips,
                    SUM(hours_worked) as total_hours,
                    AVG(total_amount) as avg_tips
                FROM tips 
                WHERE user_id = ? AND tips_date >= ? AND tips_date <= ?
            ''', (user_id, start_date, end_date)) as cursor:
                row = await cursor.fetchone()
                return dict(row) if row else None
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∑–∞ –ø–µ—Ä–∏–æ–¥: {e}")
            return None
    
    async def get_all_users(self):
        """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –∑–∞–ø–∏—Å—è–º–∏ –æ —á–∞–µ–≤—ã—Ö"""
        try:
            db = await self.connect()
            async with db.execute('SELECT DISTINCT user_id FROM tips') as cursor:
                rows = await cursor.fetchall()
                return [row['user_id'] for row in rows]
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {e}")
            return []
    
    # ===== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ê–í–ò–¢–û =====
    
    async def add_avito_sale(self, user_id: int, item_name: str, amount: float, sale_date: str):
        """–î–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–¥–∞–∂—É –Ω–∞ –ê–≤–∏—Ç–æ"""
        try:
            db = await self.connect()
            cursor = await db.execute('''
                INSERT INTO avito_sales (user_id, item_name, amount, sale_date)
                VALUES (?, ?, ?, ?)
            ''', (user_id, item_name, amount, sale_date))
            await db.commit()
            return cursor.lastrowid
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –ø—Ä–æ–¥–∞–∂–∏ –ê–≤–∏—Ç–æ: {e}")
            return None
    
    async def get_user_avito_sales(self, user_id: int, limit: int = None, offset: int = 0):
        """–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –ø—Ä–æ–¥–∞–∂–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            db = await self.connect()
            query = 'SELECT * FROM avito_sales WHERE user_id = ? ORDER BY sale_date DESC, created_at DESC'
            if limit:
                query += f' LIMIT {limit} OFFSET {offset}'
            
            async with db.execute(query, (user_id,)) as cursor:
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø—Ä–æ–¥–∞–∂ –ê–≤–∏—Ç–æ: {e}")
            return []
    
    async def count_user_avito_sales(self, user_id: int):
        """–ü–æ–¥—Å—á–∏—Ç–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ–¥–∞–∂"""
        try:
            db = await self.connect()
            async with db.execute('SELECT COUNT(*) as count FROM avito_sales WHERE user_id = ?', (user_id,)) as cursor:
                row = await cursor.fetchone()
                return row['count'] if row else 0
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥—Å—á–µ—Ç–µ –ø—Ä–æ–¥–∞–∂ –ê–≤–∏—Ç–æ: {e}")
            return 0
    
    async def get_avito_stats(self, user_id: int):
        """–ü–æ–ª—É—á–∏—Ç—å –æ–±—â—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –ê–≤–∏—Ç–æ"""
        try:
            db = await self.connect()
            async with db.execute('''
                SELECT 
                    COUNT(*) as sales_count,
                    SUM(amount) as total_amount,
                    AVG(amount) as avg_amount
                FROM avito_sales WHERE user_id = ?
            ''', (user_id,)) as cursor:
                row = await cursor.fetchone()
                return dict(row) if row else None
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ê–≤–∏—Ç–æ: {e}")
            return None
    
    async def delete_avito_sale(self, sale_id: int, user_id: int):
        """–£–¥–∞–ª–∏—Ç—å –ø—Ä–æ–¥–∞–∂—É"""
        try:
            db = await self.connect()
            await db.execute(
                'DELETE FROM avito_sales WHERE id = ? AND user_id = ?',
                (sale_id, user_id)
            )
            await db.commit()
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ø—Ä–æ–¥–∞–∂–∏ –ê–≤–∏—Ç–æ: {e}")
    
    # ===== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –†–ê–°–•–û–î–û–í =====
    
    async def add_expense(self, user_id: int, category: str, name: str, amount: float, expense_date: str, note: str = None):
        """–î–æ–±–∞–≤–∏—Ç—å —Ç—Ä–∞—Ç—É"""
        try:
            db = await self.connect()
            cursor = await db.execute('''
                INSERT INTO expenses (user_id, category, name, amount, expense_date, note)
                VALUES (?, ?, ?, ?, ?, ?)
            ''', (user_id, category, name, amount, expense_date, note))
            await db.commit()
            return cursor.lastrowid
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Ç—Ä–∞—Ç—ã: {e}")
            return None
    
    async def get_user_expenses(self, user_id: int, limit: int = None, offset: int = 0):
        """–ü–æ–ª—É—á–∏—Ç—å —Ç—Ä–∞—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            db = await self.connect()
            query = 'SELECT * FROM expenses WHERE user_id = ? ORDER BY expense_date DESC, created_at DESC'
            if limit:
                query += f' LIMIT {limit} OFFSET {offset}'
            
            async with db.execute(query, (user_id,)) as cursor:
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ç—Ä–∞—Ç: {e}")
            return []
    
    async def get_expenses_by_category(self, user_id: int, month_year: str):
        """–ü–æ–ª—É—á–∏—Ç—å —Ç—Ä–∞—Ç—ã –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º –∑–∞ –º–µ—Å—è—Ü"""
        try:
            db = await self.connect()
            async with db.execute('''
                SELECT category, SUM(amount) as total
                FROM expenses
                WHERE user_id = ? AND substr(expense_date, 4, 7) = ?
                GROUP BY category
            ''', (user_id, month_year)) as cursor:
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ç—Ä–∞—Ç –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º: {e}")
            return []
    
    async def add_recurring_expense(self, user_id: int, name: str, amount: float, payment_date: str):
        """–î–æ–±–∞–≤–∏—Ç—å –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π —Ä–∞—Å—Ö–æ–¥"""
        try:
            db = await self.connect()
            cursor = await db.execute('''
                INSERT INTO recurring_expenses (user_id, name, amount, payment_date)
                VALUES (?, ?, ?, ?)
            ''', (user_id, name, amount, payment_date))
            await db.commit()
            return cursor.lastrowid
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–≥–æ —Ä–∞—Å—Ö–æ–¥–∞: {e}")
            return None
    
    async def get_user_recurring_expenses(self, user_id: int):
        """–ü–æ–ª—É—á–∏—Ç—å –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            db = await self.connect()
            async with db.execute('''
                SELECT * FROM recurring_expenses 
                WHERE user_id = ? 
                ORDER BY payment_date
            ''', (user_id,)) as cursor:
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö —Ä–∞—Å—Ö–æ–¥–æ–≤: {e}")
            return []
    
    # ===== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ú–ï–î–ò–ê =====
    
    async def add_movie(self, user_id: int, title: str, genre: str, year: int, overview: str, status: str, rating: int = None, notes: str = None):
        """–î–æ–±–∞–≤–∏—Ç—å —Ñ–∏–ª—å–º"""
        try:
            db = await self.connect()
            cursor = await db.execute('''
                INSERT INTO movies (user_id, title, genre, year, overview, status, rating, notes)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            ''', (user_id, title, genre, year, overview, status, rating, notes))
            await db.commit()
            return cursor.lastrowid
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Ñ–∏–ª—å–º–∞: {e}")
            return None
    
    async def get_user_movies(self, user_id: int):
        """–ü–æ–ª—É—á–∏—Ç—å —Ñ–∏–ª—å–º—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            db = await self.connect()
            async with db.execute('''
                SELECT * FROM movies 
                WHERE user_id = ? 
                ORDER BY created_at DESC
            ''', (user_id,)) as cursor:
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ñ–∏–ª—å–º–æ–≤: {e}")
            return []
    
    async def get_movie_stats(self, user_id: int):
        """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ñ–∏–ª—å–º–æ–≤"""
        try:
            db = await self.connect()
            async with db.execute('''
                SELECT 
                    COUNT(*) as total_count,
                    COUNT(CASE WHEN status = '‚úÖ –ü—Ä–æ—Å–º–æ—Ç—Ä–µ–ª' THEN 1 END) as watched_count,
                    ROUND(AVG(CASE WHEN rating IS NOT NULL THEN rating END), 1) as avg_rating
                FROM movies
                WHERE user_id = ?
            ''', (user_id,)) as cursor:
                row = await cursor.fetchone()
                return dict(row) if row else None
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Ñ–∏–ª—å–º–æ–≤: {e}")
            return None
    
    async def add_series(self, user_id: int, title: str, genre: str, year: int, overview: str, seasons: int, episodes: int, status: str, rating: int = None, notes: str = None):
        """–î–æ–±–∞–≤–∏—Ç—å —Å–µ—Ä–∏–∞–ª"""
        try:
            db = await self.connect()
            cursor = await db.execute('''
                INSERT INTO series (user_id, title, genre, year, overview, seasons, episodes, status, rating, notes)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (user_id, title, genre, year, overview, seasons, episodes, status, rating, notes))
            await db.commit()
            return cursor.lastrowid
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Å–µ—Ä–∏–∞–ª–∞: {e}")
            return None
    
    async def get_user_series(self, user_id: int):
        """–ü–æ–ª—É—á–∏—Ç—å —Å–µ—Ä–∏–∞–ª—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            db = await self.connect()
            async with db.execute('''
                SELECT * FROM series 
                WHERE user_id = ? 
                ORDER BY created_at DESC
            ''', (user_id,)) as cursor:
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–µ—Ä–∏–∞–ª–æ–≤: {e}")
            return []
    
    async def get_series_stats(self, user_id: int):
        """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å–µ—Ä–∏–∞–ª–æ–≤"""
        try:
            db = await self.connect()
            async with db.execute('''
                SELECT 
                    COUNT(*) as total_count,
                    COUNT(CASE WHEN status = '‚è≥ –°–º–æ—Ç—Ä—é' THEN 1 END) as watching_count,
                    COUNT(CASE WHEN status = '‚úÖ –ü—Ä–æ—Å–º–æ—Ç—Ä–µ–ª' THEN 1 END) as watched_count,
                    ROUND(AVG(CASE WHEN rating IS NOT NULL THEN rating END), 1) as avg_rating
                FROM series
                WHERE user_id = ?
            ''', (user_id,)) as cursor:
                row = await cursor.fetchone()
                return dict(row) if row else None
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Å–µ—Ä–∏–∞–ª–æ–≤: {e}")
            return None
    
    async def add_podcast(self, user_id: int, title: str, author: str, status: str, rating: int = None, notes: str = None):
        """–î–æ–±–∞–≤–∏—Ç—å –ø–æ–¥–∫–∞—Å—Ç"""
        try:
            db = await self.connect()
            cursor = await db.execute('''
                INSERT INTO podcasts (user_id, title, author, status, rating, notes)
                VALUES (?, ?, ?, ?, ?, ?)
            ''', (user_id, title, author, status, rating, notes))
            await db.commit()
            return cursor.lastrowid
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –ø–æ–¥–∫–∞—Å—Ç–∞: {e}")
            return None
    
    async def get_user_podcasts(self, user_id: int):
        """–ü–æ–ª—É—á–∏—Ç—å –ø–æ–¥–∫–∞—Å—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            db = await self.connect()
            async with db.execute('''
                SELECT * FROM podcasts 
                WHERE user_id = ? 
                ORDER BY created_at DESC
            ''', (user_id,)) as cursor:
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø–æ–¥–∫–∞—Å—Ç–æ–≤: {e}")
            return []
    
    async def get_podcast_stats(self, user_id: int):
        """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ–¥–∫–∞—Å—Ç–æ–≤"""
        try:
            db = await self.connect()
            async with db.execute('''
                SELECT 
                    COUNT(*) as total_count,
                    COUNT(CASE WHEN status = '‚úÖ –ü—Ä–æ—Å–º–æ—Ç—Ä–µ–ª' THEN 1 END) as listened_count,
                    ROUND(AVG(CASE WHEN rating IS NOT NULL THEN rating END), 1) as avg_rating
                FROM podcasts
                WHERE user_id = ?
            ''', (user_id,)) as cursor:
                row = await cursor.fetchone()
                return dict(row) if row else None
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ–¥–∫–∞—Å—Ç–æ–≤: {e}")
            return None
    
    async def update_movie_status(self, movie_id: int, user_id: int, new_status: str):
        """–û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å —Ñ–∏–ª—å–º–∞"""
        try:
            db = await self.connect()
            await db.execute('UPDATE movies SET status = ? WHERE id = ? AND user_id = ?', (new_status, movie_id, user_id))
            await db.commit()
            return True
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞ —Ñ–∏–ª—å–º–∞: {e}")
            return False
    
    async def update_series_status(self, series_id: int, user_id: int, new_status: str):
        """–û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å —Å–µ—Ä–∏–∞–ª–∞"""
        try:
            db = await self.connect()
            await db.execute('UPDATE series SET status = ? WHERE id = ? AND user_id = ?', (new_status, series_id, user_id))
            await db.commit()
            return True
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞ —Å–µ—Ä–∏–∞–ª–∞: {e}")
            return False
    
    async def delete_movie(self, movie_id: int, user_id: int):
        """–£–¥–∞–ª–∏—Ç—å —Ñ–∏–ª—å–º"""
        try:
            db = await self.connect()
            await db.execute('DELETE FROM movies WHERE id = ? AND user_id = ?', (movie_id, user_id))
            await db.commit()
            return True
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ñ–∏–ª—å–º–∞: {e}")
            return False
    
    async def delete_series(self, series_id: int, user_id: int):
        """–£–¥–∞–ª–∏—Ç—å —Å–µ—Ä–∏–∞–ª"""
        try:
            db = await self.connect()
            await db.execute('DELETE FROM series WHERE id = ? AND user_id = ?', (series_id, user_id))
            await db.commit()
            return True
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å–µ—Ä–∏–∞–ª–∞: {e}")
            return False
    
    async def delete_podcast(self, podcast_id: int, user_id: int):
        """–£–¥–∞–ª–∏—Ç—å –ø–æ–¥–∫–∞—Å—Ç"""
        try:
            db = await self.connect()
            await db.execute('DELETE FROM podcasts WHERE id = ? AND user_id = ?', (podcast_id, user_id))
            await db.commit()
            return True
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ø–æ–¥–∫–∞—Å—Ç–∞: {e}")
            return False
    
    # ==================== –ó–ê–ú–ï–¢–ö–ò ====================
    
    async def add_note(self, user_id: int, category: str, text: str):
        """–î–æ–±–∞–≤–∏—Ç—å –∑–∞–º–µ—Ç–∫—É"""
        try:
            db = await self.connect()
            cursor = await db.execute(
                'INSERT INTO notes (user_id, category, text) VALUES (?, ?, ?)',
                (user_id, category, text)
            )
            await db.commit()
            return cursor.lastrowid
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –∑–∞–º–µ—Ç–∫–∏: {e}")
            return None
    
    async def get_user_notes(self, user_id: int, limit: int = None, offset: int = 0, category: str = None):
        """–ü–æ–ª—É—á–∏—Ç—å –∑–∞–º–µ—Ç–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            db = await self.connect()
            query = 'SELECT * FROM notes WHERE user_id = ?'
            params = [user_id]
            
            if category:
                query += ' AND category = ?'
                params.append(category)
            
            query += ' ORDER BY created_at DESC'
            
            if limit:
                query += ' LIMIT ? OFFSET ?'
                params.extend([limit, offset])
            
            async with db.execute(query, params) as cursor:
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∑–∞–º–µ—Ç–æ–∫: {e}")
            return []
    
    async def count_user_notes(self, user_id: int, category: str = None):
        """–ü–æ–¥—Å—á–∏—Ç–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–º–µ—Ç–æ–∫"""
        try:
            db = await self.connect()
            query = 'SELECT COUNT(*) as count FROM notes WHERE user_id = ?'
            params = [user_id]
            
            if category:
                query += ' AND category = ?'
                params.append(category)
            
            async with db.execute(query, params) as cursor:
                row = await cursor.fetchone()
                return row['count'] if row else 0
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥—Å—á—ë—Ç–µ –∑–∞–º–µ—Ç–æ–∫: {e}")
            return 0
    
    async def search_notes(self, user_id: int, search_text: str):
        """–ü–æ–∏—Å–∫ –∑–∞–º–µ—Ç–æ–∫ –ø–æ —Ç–µ–∫—Å—Ç—É"""
        try:
            db = await self.connect()
            async with db.execute(
                'SELECT * FROM notes WHERE user_id = ? AND text LIKE ? ORDER BY created_at DESC',
                (user_id, f'%{search_text}%')
            ) as cursor:
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ –∑–∞–º–µ—Ç–æ–∫: {e}")
            return []
    
    async def update_note(self, note_id: int, user_id: int, new_text: str):
        """–û–±–Ω–æ–≤–∏—Ç—å —Ç–µ–∫—Å—Ç –∑–∞–º–µ—Ç–∫–∏"""
        try:
            db = await self.connect()
            await db.execute(
                'UPDATE notes SET text = ? WHERE id = ? AND user_id = ?',
                (new_text, note_id, user_id)
            )
            await db.commit()
            return True
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∑–∞–º–µ—Ç–∫–∏: {e}")
            return False
    
    async def delete_note(self, note_id: int, user_id: int):
        """–£–¥–∞–ª–∏—Ç—å –∑–∞–º–µ—Ç–∫—É"""
        try:
            db = await self.connect()
            await db.execute('DELETE FROM notes WHERE id = ? AND user_id = ?', (note_id, user_id))
            await db.commit()
            return True
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∑–∞–º–µ—Ç–∫–∏: {e}")
            return False
    
    # ==================== –í–ò–®–õ–ò–°–¢ ====================
    
    async def add_wishlist_item(self, user_id: int, name: str, size_category: str, 
                               type_category: str, price: float = None, priority: str = None,
                               photo_url: str = None, link: str = None):
        """–î–æ–±–∞–≤–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –≤ –≤–∏—à–ª–∏—Å—Ç"""
        try:
            db = await self.connect()
            cursor = await db.execute('''
                INSERT INTO wishlist (user_id, name, size_category, type_category, price, priority, photo_url, link)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            ''', (user_id, name, size_category, type_category, price, priority, photo_url, link))
            await db.commit()
            return cursor.lastrowid
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –≤ –≤–∏—à–ª–∏—Å—Ç: {e}")
            return None
    
    async def get_user_wishlist(self, user_id: int, size_category: str = None, priority: str = None):
        """–ü–æ–ª—É—á–∏—Ç—å –≤–∏—à–ª–∏—Å—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            db = await self.connect()
            
            query = 'SELECT * FROM wishlist WHERE user_id = ?'
            params = [user_id]
            
            if size_category:
                query += ' AND size_category = ?'
                params.append(size_category)
            
            if priority:
                query += ' AND priority = ?'
                params.append(priority)
            
            query += ' ORDER BY created_at DESC'
            
            async with db.execute(query, params) as cursor:
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –≤–∏—à–ª–∏—Å—Ç–∞: {e}")
            return []
    
    async def delete_wishlist_item(self, item_id: int, user_id: int):
        """–£–¥–∞–ª–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –∏–∑ –≤–∏—à–ª–∏—Å—Ç–∞"""
        try:
            db = await self.connect()
            await db.execute('DELETE FROM wishlist WHERE id = ? AND user_id = ?', (item_id, user_id))
            await db.commit()
            return True
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∏–∑ –≤–∏—à–ª–∏—Å—Ç–∞: {e}")
            return False
    
    async def count_user_wishlist(self, user_id: int, size_category: str = None):
        """–ü–æ–¥—Å—á–∏—Ç–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ –≤–∏—à–ª–∏—Å—Ç–µ"""
        try:
            db = await self.connect()
            
            query = 'SELECT COUNT(*) as count FROM wishlist WHERE user_id = ?'
            params = [user_id]
            
            if size_category:
                query += ' AND size_category = ?'
                params.append(size_category)
            
            async with db.execute(query, params) as cursor:
                row = await cursor.fetchone()
                return row['count'] if row else 0
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥—Å—á—ë—Ç–µ –≤–∏—à–ª–∏—Å—Ç–∞: {e}")
            return 0
    
    async def get_wishlist_item(self, item_id: int, user_id: int):
        """–ü–æ–ª—É—á–∏—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç –≤–∏—à–ª–∏—Å—Ç–∞"""
        try:
            db = await self.connect()
            async with db.execute(
                'SELECT * FROM wishlist WHERE id = ? AND user_id = ?',
                (item_id, user_id)
            ) as cursor:
                row = await cursor.fetchone()
                return dict(row) if row else None
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —ç–ª–µ–º–µ–Ω—Ç–∞ –≤–∏—à–ª–∏—Å—Ç–∞: {e}")
            return None
    
    async def update_wishlist_item(self, item_id: int, user_id: int, **kwargs):
        """–û–±–Ω–æ–≤–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –≤–∏—à–ª–∏—Å—Ç–∞"""
        try:
            db = await self.connect()
            # –§–æ—Ä–º–∏—Ä—É–µ–º SET —á–∞—Å—Ç—å –∑–∞–ø—Ä–æ—Å–∞ —Ç–æ–ª—å–∫–æ –¥–ª—è –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã—Ö –ø–æ–ª–µ–π
            set_parts = []
            values = []
            for key, value in kwargs.items():
                set_parts.append(f"{key} = ?")
                values.append(value)
            
            if not set_parts:
                return False
            
            values.extend([item_id, user_id])
            query = f"UPDATE wishlist SET {', '.join(set_parts)} WHERE id = ? AND user_id = ?"
            await db.execute(query, values)
            await db.commit()
            return True
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —ç–ª–µ–º–µ–Ω—Ç–∞ –≤–∏—à–ª–∏—Å—Ç–∞: {e}")
            return False

    # ===== –ù–ê–ü–û–ú–ò–ù–ê–ù–ò–Ø =====
    
    async def create_reminder(self, user_id: int, priority: int, reminder_datetime: str, note: str, repeat_type: str = 'none') -> bool:
        """–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤–æ–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ"""
        try:
            db = await self.connect()
            await db.execute(
                "INSERT INTO reminders (user_id, priority, reminder_datetime, note, repeat_type, created_at) VALUES (?, ?, ?, ?, ?, ?)",
                (user_id, priority, reminder_datetime, note, repeat_type, datetime.now().isoformat())
            )
            await db.commit()
            return True
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è: {e}")
            return False

    async def get_user_reminders(self, user_id: int) -> list:
        """–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            db = await self.connect()
            cursor = await db.execute(
                "SELECT * FROM reminders WHERE user_id = ? ORDER BY reminder_datetime ASC",
                (user_id,)
            )
            reminders = await cursor.fetchall()
            return [dict(reminder) for reminder in reminders]
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π: {e}")
            return []

    async def get_due_reminders(self) -> list:
        """–ü–æ–ª—É—á–∏—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–µ–π—á–∞—Å"""
        try:
            db = await self.connect()
            # –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º –ø–æ UTC –≤—Ä–µ–º–µ–Ω–∏
            from datetime import timezone
            now = datetime.now(timezone.utc).isoformat()
            
            # –ü–æ–ª—É—á–∞–µ–º –æ–±—ã—á–Ω—ã–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è (–Ω–µ –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–µ—Å—è)
            cursor = await db.execute(
                "SELECT * FROM reminders WHERE reminder_datetime <= ? AND sent = 0 AND repeat_type = 'none' ORDER BY priority ASC, reminder_datetime ASC",
                (now,)
            )
            regular_reminders = await cursor.fetchall()
            
            # –ü–æ–ª—É—á–∞–µ–º –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–µ—Å—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è (–ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –±–µ–∑ —É—á–µ—Ç–∞ –¥–∞—Ç—ã)
            cursor = await db.execute(
                "SELECT * FROM reminders WHERE repeat_type != 'none' ORDER BY priority ASC, reminder_datetime ASC"
            )
            recurring_reminders = await cursor.fetchall()
            
            # –§–∏–ª—å—Ç—Ä—É–µ–º –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–µ—Å—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –ø–æ –≤—Ä–µ–º–µ–Ω–∏
            filtered_recurring = []
            now_utc = datetime.now(timezone.utc)
            
            for reminder in recurring_reminders:
                reminder_dt = datetime.fromisoformat(reminder['reminder_datetime'])
                if reminder_dt.tzinfo is None:
                    reminder_dt = reminder_dt.replace(tzinfo=timezone.utc)
                
                reminder_time = reminder_dt.time()
                now_time = now_utc.time()
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–¥—Ö–æ–¥–∏—Ç –ª–∏ –≤—Ä–µ–º—è (—Å —Ç–æ—á–Ω–æ—Å—Ç—å—é –¥–æ –º–∏–Ω—É—Ç—ã)
                time_matches = (reminder_time.hour == now_time.hour and 
                               reminder_time.minute == now_time.minute)
                
                if time_matches:
                    repeat_type = reminder.get('repeat_type', 'none')
                    
                    if repeat_type == 'daily':
                        # –ï–∂–µ–¥–Ω–µ–≤–Ω—ã–µ - –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–∞–∂–¥—ã–π –¥–µ–Ω—å
                        filtered_recurring.append(reminder)
                    elif repeat_type == 'weekly':
                        # –ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω—ã–µ - –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ —Ç–æ—Ç –∂–µ –¥–µ–Ω—å –Ω–µ–¥–µ–ª–∏
                        reminder_weekday = reminder_dt.weekday()
                        now_weekday = now_utc.weekday()
                        if reminder_weekday == now_weekday:
                            filtered_recurring.append(reminder)
            
            all_reminders = list(regular_reminders) + filtered_recurring
            return [dict(reminder) for reminder in all_reminders]
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã—Ö –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π: {e}")
            return []

    async def mark_reminder_sent(self, reminder_id: int) -> bool:
        """–û—Ç–º–µ—Ç–∏—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –∫–∞–∫ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–µ"""
        try:
            db = await self.connect()
            await db.execute(
                "UPDATE reminders SET sent = 1 WHERE id = ?",
                (reminder_id,)
            )
            await db.commit()
            return True
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–º–µ—Ç–∫–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –∫–∞–∫ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–≥–æ: {e}")
            return False

    async def delete_reminder(self, reminder_id: int, user_id: int) -> bool:
        """–£–¥–∞–ª–∏—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ"""
        try:
            db = await self.connect()
            await db.execute(
                "DELETE FROM reminders WHERE id = ? AND user_id = ?",
                (reminder_id, user_id)
            )
            await db.commit()
            return True
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è: {e}")
            return False

    async def update_reminder(self, reminder_id: int, user_id: int, **kwargs) -> bool:
        """–û–±–Ω–æ–≤–∏—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ"""
        try:
            db = await self.connect()
            set_parts = []
            values = []
            
            for key, value in kwargs.items():
                if key in ['priority', 'reminder_datetime', 'note']:
                    set_parts.append(f"{key} = ?")
                    values.append(value)
            
            if not set_parts:
                return False
                
            values.extend([reminder_id, user_id])
            query = f"UPDATE reminders SET {', '.join(set_parts)} WHERE id = ? AND user_id = ?"
            await db.execute(query, values)
            await db.commit()
            return True
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è: {e}")
            return False

    # ===== –ö–ê–î–†–´ –î–õ–Ø –í–ò–î–ï–û–ì–†–ê–§–ò–ò =====
    
    async def create_video_frame(self, user_id: int, title: str, description: str, instructions: str = None, duration: int = None) -> int:
        """–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –∫–∞–¥—Ä"""
        try:
            db = await self.connect()
            # –ü–æ–ª—É—á–∞–µ–º —Å–ª–µ–¥—É—é—â–∏–π –ø–æ—Ä—è–¥–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä
            cursor = await db.execute(
                "SELECT MAX(order_index) FROM video_frames WHERE user_id = ?",
                (user_id,)
            )
            max_order = await cursor.fetchone()
            next_order = (max_order[0] or 0) + 1
            
            cursor = await db.execute(
                "INSERT INTO video_frames (user_id, title, description, instructions, duration, order_index, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)",
                (user_id, title, description, instructions, duration, next_order, datetime.now().isoformat())
            )
            await db.commit()
            return cursor.lastrowid
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∫–∞–¥—Ä–∞: {e}")
            return None

    async def get_user_video_frames(self, user_id: int) -> list:
        """–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∫–∞–¥—Ä—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            db = await self.connect()
            cursor = await db.execute(
                "SELECT * FROM video_frames WHERE user_id = ? ORDER BY order_index ASC",
                (user_id,)
            )
            frames = await cursor.fetchall()
            return [dict(frame) for frame in frames]
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∫–∞–¥—Ä–æ–≤: {e}")
            return []

    async def get_video_frame(self, frame_id: int, user_id: int) -> dict:
        """–ü–æ–ª—É—á–∏—Ç—å –∫–∞–¥—Ä –ø–æ ID"""
        try:
            db = await self.connect()
            cursor = await db.execute(
                "SELECT * FROM video_frames WHERE id = ? AND user_id = ?",
                (frame_id, user_id)
            )
            frame = await cursor.fetchone()
            return dict(frame) if frame else None
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∫–∞–¥—Ä–∞: {e}")
            return None

    async def update_video_frame(self, frame_id: int, user_id: int, **kwargs) -> bool:
        """–û–±–Ω–æ–≤–∏—Ç—å –∫–∞–¥—Ä"""
        try:
            db = await self.connect()
            set_parts = []
            values = []
            
            for key, value in kwargs.items():
                if key in ['title', 'description', 'instructions', 'duration', 'order_index']:
                    set_parts.append(f"{key} = ?")
                    values.append(value)
            
            if not set_parts:
                return False
                
            values.extend([frame_id, user_id])
            query = f"UPDATE video_frames SET {', '.join(set_parts)} WHERE id = ? AND user_id = ?"
            await db.execute(query, values)
            await db.commit()
            return True
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∫–∞–¥—Ä–∞: {e}")
            return False

    async def delete_video_frame(self, frame_id: int, user_id: int) -> bool:
        """–£–¥–∞–ª–∏—Ç—å –∫–∞–¥—Ä"""
        try:
            db = await self.connect()
            await db.execute(
                "DELETE FROM video_frames WHERE id = ? AND user_id = ?",
                (frame_id, user_id)
            )
            await db.commit()
            return True
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∫–∞–¥—Ä–∞: {e}")
            return False

    # ===== –ò–î–ï–ò =====
    
    async def create_idea(self, user_id: int, category: str, idea_text: str, songs: str = None, priority: int = 3) -> int:
        """–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –∏–¥–µ—é"""
        try:
            db = await self.connect()
            cursor = await db.execute(
                "INSERT INTO ideas (user_id, category, idea_text, songs, priority, created_at) VALUES (?, ?, ?, ?, ?, ?)",
                (user_id, category, idea_text, songs, priority, datetime.now().isoformat())
            )
            await db.commit()
            return cursor.lastrowid
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∏–¥–µ–∏: {e}")
            return None

    async def get_user_ideas(self, user_id: int) -> list:
        """–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∏–¥–µ–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            db = await self.connect()
            cursor = await db.execute(
                "SELECT * FROM ideas WHERE user_id = ? ORDER BY priority ASC, created_at DESC",
                (user_id,)
            )
            ideas = await cursor.fetchall()
            return [dict(idea) for idea in ideas]
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∏–¥–µ–π: {e}")
            return []

    async def get_idea(self, idea_id: int, user_id: int) -> dict:
        """–ü–æ–ª—É—á–∏—Ç—å –∏–¥–µ—é –ø–æ ID"""
        try:
            db = await self.connect()
            cursor = await db.execute(
                "SELECT * FROM ideas WHERE id = ? AND user_id = ?",
                (idea_id, user_id)
            )
            idea = await cursor.fetchone()
            return dict(idea) if idea else None
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∏–¥–µ–∏: {e}")
            return None

    async def update_idea(self, idea_id: int, user_id: int, **kwargs) -> bool:
        """–û–±–Ω–æ–≤–∏—Ç—å –∏–¥–µ—é"""
        try:
            db = await self.connect()
            set_parts = []
            values = []
            
            for key, value in kwargs.items():
                if key in ['category', 'idea_text', 'songs', 'priority']:
                    set_parts.append(f"{key} = ?")
                    values.append(value)
            
            if not set_parts:
                return False
                
            values.extend([idea_id, user_id])
            query = f"UPDATE ideas SET {', '.join(set_parts)} WHERE id = ? AND user_id = ?"
            await db.execute(query, values)
            await db.commit()
            return True
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∏–¥–µ–∏: {e}")
            return False

    async def delete_idea(self, idea_id: int, user_id: int) -> bool:
        """–£–¥–∞–ª–∏—Ç—å –∏–¥–µ—é"""
        try:
            db = await self.connect()
            await db.execute(
                "DELETE FROM ideas WHERE id = ? AND user_id = ?",
                (idea_id, user_id)
            )
            await db.commit()
            return True
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∏–¥–µ–∏: {e}")
            return False

